/* sample7.c */

/*
 * sample6.cではfor文を用いて配列のコピーを行いました。
 * しかし、for文を使わなくても、memcpy関数を使うことで同様の処理を行うことができます。
 * 
 * memcpy関数を使うには、memory.hファイルをincludeする必要があります。
 * 
 * -memcpy関数-------------------------------------
 *  memcpy(コピー先配列名, コピー元配列名, 配列全体のサイズ)
 * ----------------------------------------------
 * 
 * 配列全体のサイズは配列の型や要素数によって変わってくるので、
 * この関数では、sizeof演算子で得られたサイズを元にします。
 * 
 * 配列のすべての要素をコピーするには、sizeof演算子で配列名を指定します。
 * 次のプログラムは、memcpy関数で配列をコピーする例です。
 */

#include <stdio.h>
#include <memory.h>

int main(void)
{
    int array1[] = {42, 79, 13, 19, 41};
    int array2[] = {1, 2, 3, 4, 5};
    int i;

    /* 要素数の計算:
     * array1もarray2も要素数が同じなのが見てすぐにわかるため、
     * 今回はarray1の要素数だけ計算した。
     */

    int array_count = sizeof(array1) / sizeof(array1[0]);

    /* array2の全要素を表示 */
    for (i = 0; i < array_count; i++) {
        printf("array2[%d] = %d\n", i, array2[i]);
    }

    /* tips: sizeof(array1)を画面出力したらどうなる...? */
    printf("array1のサイズは %lu です。\n", sizeof(array1));
    /* 実行結果は20。<- intは1つ当り4バイトなので、4×5=20 となる。 */
    /* 要素数は「合計のサイズ ÷ 1つあたりのサイズ」を計算しているため、上記のarray_countのような割り算で要素数を求めることができる。 */

    /* array1の全要素をarray2にコピー */
    memcpy(array2, array1, sizeof(array1));

    /* array2の全要素を表示 */
    for (i = 0; i < array_count; i++) {
        printf("array[%d] = %d\n", i, array2[i]);
    }

    return 0;
}

/*
 * 実行結果は、先ほどとまったく同じになります。
 * 
 * -バッファオーバーラン-----------------------------------
 * 上記では、コピー元の配列(array1)と、コピー先の配列(array2)は同じ長さです。
 * したがって、はみ出したりすることなく、ぴったりコピーされます。
 * 
 * しかし、困ったことに、memcpy関数はそれぞれの配列の長さを考慮してくれません。
 * コピー元の配列が、コピー先より長くても、無理やり全部コピーしてしまいます。
 * 
 * そのため長い部分がはみ出してコピーされてしまいます。
 * その結果、無関係の他の変数や配列を上書きして、重大な計算エラーを引き起こします。
 * これが、悪名高いバグである「バッファオーバーラン」です。
 * アプリやパソコンが突然止まったりする原因の多くが、このバッファオーバーランです。
 * 
 * ※ はみ出してコピーされただけの場合はバッファオーバーフローといいます。
 * ----------------------------------------------
 * 
 * C言語は、とてもバグがおきやすい言語です。
 * ちょっとプログラムを間違えると、すぐにアプリが止まってしまいます。
 * JavaやC#やRustなどのより新しいプログラミング言語は、
 * バッファオーバーランがなるべく怒らないように設計されています。
 */
