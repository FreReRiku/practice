/* sample8.c */
/* 関数内で生き残る変数 */

/* 静的なローカル変数の寿命
 * これまで、ローカル変数とグローバル変数の
 * 寿命の異なる変数を取り上げてきましたが、
 * 実は、この2つの中間的な存在である、
 * 変わった特徴を持つ変数が存在します。
 * 関数内で変数を宣言する時に、
 * 型名の前にstatic(スタティック)とつけることで、
 * 静的なローカル変数を宣言できます。
 * 
 * 次のプログラムは、静的なローカル変数を宣言した例です。
 */

#include <stdio.h>

int countfunc(void);

int main(void)
{
    countfunc();
    countfunc();
    countfunc();

    return 0;
}

int countfunc(void)
{
    static int count; /* 静的なローカル変数 */

    count++;
    printf("%d\n", count);

    return count;
}

/*
 * 関数内で宣言したのにもかかわらず、呼び出し毎に値が1ずつ増えていますし、
 * 初期化も行っていないのに、始めの値が0になっています。
 * これは、どう見てもグローバル変数にしか見えません。
 * 
 * しかし、変数countは関数内で宣言されているため
 * 本質的にはローカル変数です。
 * 実際、main関数内で変数countを使用すると、エラーとなります。
 * 
 * これが、静的なローカル変数の特徴です。
 * 関数内で宣言されているので、使用できるのは宣言された関数内のみですが、
 * その値はプログラムが終了するまで残るのです。
 * また、とくに初期化しなくても、自動的に0に初期化されます。
 * 
 * なお、初期化ははじめに1回だけしか行われませんので、
 * 例えば、次のように初期化を行った場合もカウントできます。
 * 
 * -ソースコード---------------------------------------
 *  static int count = 0;   // 静的なローカル変数
 * ----------------------------------------------
 * 
 * この変数は、関数が以前に呼び出されたときの値を覚えておきたい
 * 場合に使用されます。
 * 使い道は限られますが、関数の呼び出し回数を数える場合や、
 * 検索を行う関数で、以前に見つかった門司市を記憶する場合などが
 * 考えられます。
 */
