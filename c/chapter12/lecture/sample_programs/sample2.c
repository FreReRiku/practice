/* sample2.c */

/*
 * sample1.cで書いたコードでは
 * もしかしたら、初期化の部分で0を代入していることが原因かもしれません。
 * 
 * そこで、あえて警告を無視して、変数を初期化せずに使ってみたいと思います(思いついたものやっていく戦法)。
 * この場合、初めにどんな数字が出るかわかりませんが、
 * それでも、2回目の呼び出しでは1回目の呼び出しより1多く、3回目は2多くなるはずです。
 * 次のプログラムは、変数countを初期化しない例です。
 */

#include <stdio.h>

int countfunc(void);

int main(void)
{
    countfunc();
    countfunc();
    countfunc();

    return 0;
}

int countfunc(void)
{
    int count = 0;  /* 初期化しないでやってみた(本当はやってはいけない) */
    count++;

    printf("%d\n", count);
    return count;
}

/* sample2.cの実行結果について
 * 私の実行環境では、sample2.cを実行すると
 * -実行結果------------------------------
 * 2
 * 3
 * 4
 * -----------------------------------
 * となりました。
 */

/* 変数の寿命について
 * 実は、関数の中で宣言された変数は
 * 関数が終了すると捨てられてしまうのです。
 * 再び、同じ関数が呼び出された場合は
 * もう一度変数を作り直します。
 * この時、前回とは別のメモリが使われるので
 * 値も変わってしまいます。
 * 
 * 偶然同じ値が出てくることもあります。
 * これも、結局のところ「まったく偶然の産物」です。
 * 同じ値が出るのか、別の値が出るのかはわかりません。
 * 
 * つまり、関数の中で宣言された変数の寿命は
 * 関数の中だけであるということです。
 * このように、関数の中で寿命が終わる変数を
 * ローカル変数と呼びます。
 * また、変数の寿命や有効範囲などをまとめて
 * スコープと呼ぶことがあります。
 * 
 * -キーワード----------------------------------------
 *  【ローカル変数】
 *  関数の中で宣言された変数。
 *  仮引数の変数も同様、その関数が終わると捨てられ、
 *  再度関数が呼ばれた時には新しく作られる。
 *  また、他の関数から使用することは出来ない。
 * ----------------------------------------------
 * 
 * -キーワード----------------------------------------
 *  【スコープ】
 *  識別子(一意の名前で識別された変数)が有効な範囲を
 *  制限する仕組みの総称。
 *  一般的には、変数の寿命と有効範囲を決定する仕組み。
 * ----------------------------------------------
 */
