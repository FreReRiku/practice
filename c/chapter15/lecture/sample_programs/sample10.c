/* sample10.c */

/* sample9.cのつづき
 * 次のプログラムは、printf関数でアドレスを表示して確かめる例です。
 */

#include <stdio.h>

int main(void)
{
    int *p;
    int i;
    p = &i;
    printf("p  = %p\n", p);     /* ポインタ変数pは、intへのポインタ型 */
    printf("&i = %p\n", &i);    /* 変数iの型はint型ですが、&演算子を使って得られるアドレスはポインタ型 */

    return 0;
}

/*
 * 見事に同じ値になっています。
 * このことは、ポインタ変数も変数であることからすれば、ある意味当然です。
 * だって、pに&iを代入して、直後にその値を表示しているのですから。
 * 
 * ただし、ここでは型に注意してください。
 * ポインタ変数pの型は、intへのポインタ型という型です。
 * 変数iの型はint型ですが、&演算子を使って得られるアドレスはポインタ型です。
 * したがって、&iをpに代入することができ、また両方ともに%p指定子で表示できるのです。
 * 
 * -ヌルポインタ---------------------------------------
 * ポインタ変数も宣言した直後はデタラメな値が代入されています。
 * その値が使用可能なアドレスなのかはまったくわからないので、
 * 勘違いでそのアドレスを使ってしまうと確実にバグになります。
 * 
 * これを防ぐにはアドレスを代入したかを区別する必要があります。
 * そこで、C言語には、ヌルポインタが用意されています。
 * NULLという記号をポインタ変数に代入しておけば、
 * アドレスが代入されていない、つまり、まだ使える状態になっていないことを示せます。
 * int *p = NULL;
 * このようにすれば、if分でp == NULLであるか比較すれば
 * pにアドレスが代入されているか区別できます。
 * ----------------------------------------------
 * 
 * -ヌルポインタは0?------------------------------------
 * int *p = 0;
 * としてもヌルポインタが代入されます。
 * これはC言語の文法として決まっていることであり、
 * NULLが0であるということではありません。
 * あくまでもNULLはNULLです。
 * NULLは正しいアドレスが代入されていないことを示すための識別用の値であり、
 * 計算に使うための数値である0とは明確に区別されます。
 * (もっとも、殆どのコンパイラではNULLは0になっていると思いますが...)
 * ----------------------------------------------
 */
