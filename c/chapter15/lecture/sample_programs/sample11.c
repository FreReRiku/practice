/* sample11.c */

/* モードの切り替え
 * 前節で説明した通り、ポインタ変数では、2モードを持っています。
 * それは、通常変数モードとポインタ変数モードです。
 * とくに何も指定せずにポインタ変数を使っている場合は、ポインタ変数モードになります。
 * 
 * 通常変数モードに切り替えるには、変数の前に*記号を付けます。
 * *記号が付けられたポインタ変数は、通常変数とまったく同じ機能になります。
 * 次のプログラムは、ポインタ変数を通常変数モードに切り替えて使う例です。
 */

#include <stdio.h>

int main(void)
{
    int *p = NULL;
    int i;

    p = &i;
    *p = 10;    /* 通常変数モードに切り替えたポインタ変数に代入 */
    printf("*p = %d\n", *p);
    printf("i  = %d\n", i);

    return 0;
}

/*
 * このプログラムでは、ポインタ変数pに*をつけて、通常変数モードに切り替えています。
 * *pは、通常変数モードに切り替わったポインタ変数pです。
 * *pである限りは、通常の変数とまったく同じように扱うことができます。
 * 
 * 通常変数モードに切り替わったポインタ変数は通常の変数と同じように機能しますが、
 * そのとき使われるメモリは、ポインタ変数モードの時に代入されたアドレスです。
 * つまり、
 * ポインタ変数モードの時に読み書きしたいメモリのアドレスを代入して、
 * その後、通常変数モードに切り替えてそのメモリを操作する
 * 
 * というのがポインタ変数のもっとも基本的な使い方となります。
 * 
 * 直接、何番のメモリを書き換えろ、と指定するのではなくて、
 * 書き換えたいメモリのアドレスを代入し、モードを切り替えて書き換えるという
 * いわば2段構になっているため、直感的にはわかりにくいかもしれません。
 * 
 * 先ほどのプログラムでは、5行目でポインタ変数pに変数iのアドレスを代入し、
 * 6行目で、pを通常変数モードに切り替えて、pが記憶したアドレスに10を代入しています。
 * この時、pが記憶したアドレスとは、つまりは変数iのアドレスなので、
 * 結果として、変数iの値は10に書き換えられていることになります。
 * 
 * もう少し具体的に説明すれば、この時、変数iと通常変数モードの*pは、
 * まったく同じメモリ領域を使っているということです。
 * *pに10を代入すると、iも自動的に10に切り替わるというのではなく、
 * この2つはそもそも同じメモリ位置を示しているのです。
 * 
 * -奇怪な記号*---------------------------------------
 * *の記号は、実に3通りの意味を持っており、混乱の原因になります。
 * ここで、3つの区別をはっきりさせておきます。
 * 
 * 1つ目は、乗算演算子です。いわゆる掛け算のことです。
 * 式の中で使用する記号で、kai = 5 * 8のようにして使用します。
 * 
 * 2つ目は、間接参照演算子です。ポインタ変数を通常変数モードにします。
 * 式の中で使用する記号で、*pのようにして使用します。
 * ポインタ変数モードの時のポインタ変数では掛け算ができないため、
 * 乗算演算子と同じ記号を使っていても区別が付きます。
 * 
 * 3つ目は、ポインタ変数を宣言する時に使用する記号です。
 * 宣言の時のみに使用され、int *pのようにして使用します。
 * ここがややこしいのですが、通常変数モードに切り替える間接参照演算子*と、
 * 宣言の時に使用する*の記号は、何の関係もないまったく別の記号です。
 * たまたま同じ文字を使っているだけのことに過ぎません。
 * 
 * この3つにはすべて別の文字を使う方がわかりやすいはずだと思います。
 * 同じ文字を割り当てているのはC言語の欠陥の1つです。
 * でも、いまさら直しようがありませんから、上記の3つが
 * 別の意味の記号であることをしっかり認識してください。
 * ----------------------------------------------
 */

/* すなわちショートカット
 * 前項までで、ポインタ変数の機能はすべて説明しました。
 * 実際、ポインタは、前項までで説明した通りの機能しか持っていません。
 * ポインタ変数モードの時にメモリのアドレスを代入して、
 * 通常変数モードに切り替えてからそのメモリを操作する。
 * これがポインタの全機能です。
 * 
 * ここまでを理解した上で、当然でてくる疑問があります。
 * 結局の所、ポインタとは何の役に立つ機能なのでしょうか。
 * 前項のように、ポインタ変数モードで変数のアドレスを代入して、
 * 通常変数モードに切り替えて操作する、なんて面倒なことに何の意味があるのでしょう。
 * 
 * これはもう、疑問に思った通りで、そのような使い方では何の役にも立ちません。
 * 普通に変数を操作した方が、よほど楽で間違いも少なくなります。
 * 
 * ポインタの本当の使い方は、ショートカットとして使用することです。
 * Windowsのデスクトップに並んでいる、あのショートカットと同じです。
 * 
 * ショートカットは、どこか別の場所にあるファイルを指し示すファイルです。
 * ショートカットを開けば、その指し示しているファイルが開かれます。
 * にも関わらず、ショートカットは指し示すファイル自体ではないので、
 * ショートカットはどこにでも自由に作ることができますし、
 * 複数個作ったり削除したりしても、指し示すファイルには何の影響もありません。
 * 
 * これこそが、まさにポインタの役割そのものです。
 * ポインタ変数に、実際に存在する変数のアドレスを記憶しておけば、
 * そのポインタ変数が使える場所であれば、元の変数が使えない場所であっても、
 * ポインタ変数を通常変数モードに切り替えれば、元の変数と同じく使うことができます。
 * まさに、ショートカットのような働きをさせることができるわけです。
 * 
 * -他言語のポインタ-------------------------------------
 * 一般には、ポインタはC言語とC++のみの機能だと言われています。
 * 確かに、指定したメモリのアドレスを操作するという意味ではその通りです。
 * 
 * しかし、ポインタの本当の使い方はショートカットとして使うことであり、
 * その観点ならば、実用的なほとんどの言語にポインタがあります。
 * Javaの参照はまさしくそんな機能で、しかも頻繁に使われますし、
 * VisuaBasicのSETステートメントなども同様と言って良いでしょう。
 * 
 * そもそも、ポインタがないのでは、連結リストや木構造などの、
 * 複雑なデータ構造を実現できませんし、オブジェクト指向も困難です。
 * その意味では、仕組みが不明なJavaやVisualBasicのポインタより、
 * 仕組みがはっきりしているC言語のポインタの方が理解しやすいです。
 * 
 * 他の言語の参照と、C言語のポインタの最大の違いは、自動なのか手動なのか、です。
 * 他の言語の参照は、ほとんど自動でショートカットとして機能するようになっていますが、
 * C言語のポインタは、完全に手動であり、プログラマーが完全に理解して使わなければなりません。
 * 
 * そのかわり、上級者がC言語のポインタを使いこなすと、ポインタだけで、
 * ほぼあらゆる制御構造、あらゆるデータ構造、を実現できる、強力すぎる機能となります。
 * 実際、C言語のほとんどの機能が、ポインタで成り立っています。
 * ----------------------------------------------
 */
