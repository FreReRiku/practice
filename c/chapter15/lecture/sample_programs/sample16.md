# sample16.md

## アドレスを渡している

前項では、配列型の引数の持つ奇妙な性質を説明しました。あのような現象は、配列が値渡しされていれば、ありえないことです。

**つまり、逆に言えば、配列自体は値渡しされていないのです。**

しかし、実際に関数に配列を渡して平均値を計算することには成功しています。
つまり、何らかの形で配列が渡されていることは間違いのない事実です。

この点について検証するために、すこし実験を行ってみましょう。
まず、前項で配列型の引数では要素数は無視されていることはわかりました。
それならばいっそ、要素数を指定しなければどうなるでしょうか？

つまり、関数を次のように変更してみるのです。

```c
int getaverage(int data[]);
```

このように書き換えて実行しても、何の問題もなく動作します。
しかも、プロトタイプ宣言で要素数を指定せずに、
実際の関数の宣言では要素数をつけた場合ですら、何のエラーも出ません。
このことからも、要素数は完全に無視されていることがわかります。

しかし、要素数を無視して、どうやって配列の値を渡しているのでしょうか？
普通に考えれば、配列を渡す場合、要素数の数だけ値をコピーすることになります。
しかし、要素数を無視している以上、そのような方法は使えません。

ここで、もう一つの実験を行ってみたいと思います。
前項で、呼び出された関数で配列の値を変更すると、呼び出し元まで変化しましたが、
この現象は、ポインタ型の引数を使った時とよく似ています。
つまり、配列ではなくアドレスを渡しているのではないかとも考えられます。
試しに、関数を次のように変更してみました。

```c
int getaverage(int *data);
```

驚くべきことに、これでも、何の問題もなく動作しました。
これで、先ほどまでの奇妙な現象の原因がすべて判明しました。
つまり、配列を渡していたのではなく、配列の先頭のアドレスを渡していたのです。

配列の先頭のアドレスを渡すだけならば、要素数などまったく関係ありません。
また、呼び出された関数での配列は、呼び出し元と同じメモリ領域を指すことになるので、
呼び出された関数で配列の値を変えると、呼び出し元も変更されるのは当然です。

このことについてまとめると、まず、次の3つは同じ意味の仮引数宣言です。
ただし、この3つが同じ意味になるのは関数の仮引数宣言の場合のみです。

```c
int getaverage(int data[10]);
int getaverage(int data[]);
int getaverage(int *data);
```

そして、関数の中では、dataはいずれもポインタ型の変数です。
そして、呼び出し先と呼び出し元ではまったく同じメモリ領域の配列を使うことになります。

### どれにするか

この3つが同じ意味だと、どれを使ってよいのか迷う人もいるかもしれませんが、
2番目のように要素数を省略した形を使うことがおすすめされています。
なぜなら、3番目の宣言は、普通のポインタ型と紛らわしいからです。
2番目の宣言であれば、配列を受け取ることが明示的にわかります。
1番目の宣言は、C言語に慣れた人たちには幼稚な宣言に見えます。
