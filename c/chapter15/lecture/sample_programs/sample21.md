# sample21.md

## 古き悪きポインタ演算

前項では、ポインタ変数で配列要素へアクセスする書き方のポインタ演算を説明しました。
しかし...あの書き方はわかりやすいと思いますか?

正直わかりにくいと思います。

次の2つはまったく同じ意味なのですが、どちらがわかりやすいかは歴然です。

```c
data[5]
*(data + 5)
```

また、++を使って増加していく方のポインタ演算などはさらにひどいです。
次の2つを見て、下の方がわかりやすいと思う人はいないと思います。

```c
for (i = 0; i < 0; i++) {
    average += data[i];
}

for (data = array; data != &array[10]; data++) {
    average += *data;
}
```

さらに、++を使って増加していく方のポインタ演算は高速だと書きましたが、実は、これは昔の話だったりします。

現在では、コンパイラの性能が飛躍的にアップしています。
そして、現代のコンパイラでは、[]でアクセスしているようなループを見つければ、
自動的に、++で増加するポインタ演算のような書き方に置き換えてコンパイルします。

C言語が作られたばかりの頃は、そんなコンパイラはなかったのですが、
現代では多くのコンパイラがその程度の工夫は行ってくれます。

---
組み込みでは

ほとんどのパソコン向けのコンパイラは適切な最適化を行ってくれます。
さらに、パソコン用のCPUは内部キャッシュの仕組みが複雑かつ高性能であり、
繰り返し処理をCPUが独自に最適化して、速度を向上させるような仕組みがあります。
そのため、現代のパソコンでは、どちらの書き方でも、結局同じ速度になります。

しかし、組み込み(家電などに内蔵される低性能なコンピュータ)ではそうとは限りません。
コンパイラによる最適化は十分には機能しないことも多いですし、
CPUの仕組みが単純なので、プログラムの書き方が、速度にそのまま反映されやすくなっています。
そういった場合には、ポインタ演算は現代でも有用です。

---

昔は++ポインタ演算が結構使われており、その名残から現在でも使う人は多いのですが、
筆者いわく、わかりやすい[]を使って配列にアクセスすることをオススメしています。

## アドレスのことは忘れましょう

ここまでで、ポインタ変数の機能はほぼ説明し尽くしましたし、
ポインタ変数はアドレスを記憶する変数であることを重視して、
それにまつわるさまざまな現象を説明してきました。

しかし、実際にプログラムを作るときには、
ポインタ変数がアドレスを記憶する変数であることはさっぱりと忘れてください。

なぜなら、ポインタ変数の本当の使い方とは、変数のショートカットとして使うことだからです。
決して、アドレスを操作することではありません。
言い換えれば、ポインタ変数がアドレスを記憶するのは、あくまでも仕組みであり、使い方ではないからです。
使い方さえわかっていれば、内部処理がどんな仕組みだろうと無関係だからです。
コンピュータの仕組みをまったく知らなくてもコンピュータが使えるのと同じことです。

多くの人がポインタ変数でつまづくのは、アドレスを記憶することばかり意識するためです。
そんな内部の仕組みなど知らなくても、ポインタ変数は簡単に使えます。
変数に&を付けてショートカットを設定し、*記号を付けて通常変数モードにして使用する。
この手順にしたがって使う限り、アドレスなど何の関係もないのです。

ただし、C言語ではときおり非常に不可解なバグがでることがあります。
この場合、その原因の多くはポインタ変数の使い方を間違えているためです。
バグ修正のときにはポインタ変数がアドレスを記憶する変数であることを思い出し、
どこかで間違ったアドレスが代入されていないか調べなくてはならないでしょう。
