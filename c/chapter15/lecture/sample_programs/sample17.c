/* sample17.c */

/* 配列とポインタの奇妙な関係 */

/* 配列のような使い方
 * 前節では、関数に配列を渡すには配列の先頭要素のアドレスを渡していたと説明しました。
 * ところで、次のプログラムは、ポインタ型の引数にした前節のプログラムですが、
 * このプログラムを見て、どこか不自然な部分は見当たらないでしょうか。
 */

#include <stdio.h>

int getaverage(int *data);

int main(void)
{
    int average;
    int array[10] = {15, 78, 98, 15, 98, 85, 17, 35, 42, 15};
    average = getaverage(array);
    printf("Average: %d\n", average);
    return 0;
}

int getaverage(int *data)
{
    int i;
    int average = 0;

    for (i = 0; i < 10; i++) {
        average += data[i]; /* ポインタ変数なのに? */
    }
    
    return average / 10;
}

/*
 * この中で明らかに不自然なのは、コメントで示した行の data[i] です。
 * この変数dataはポインタ変数出会って、配列ではありません。
 * にも関わらず、[]を使って要素番号が指定できるのはどういうことでしょうか。
 * 
 * []の役割は、配列の要素番号を指定する演算子なのですが、
 * その仕組みは、単に、配列名というアドレスに足し算を行っているだけです。
 * つまり、別に配列でなくても、アドレス値なら何でも良いということになります。
 * 
 * 細かく説明すると、数式の中に配列名を記述した場合、[]の記号の有無に関わらず、
 * 配列名は、配列の戦闘要素へのアドレス(ポインタ値)として扱われます。
 * そして、その配列名に[]をつけた場合、そのアドレスに番号の値だけ足し算を行い、
 * その結果として、足し算された分の番号の要素として扱われているのです。
 * 
 * -宣言時と数式の違い------------------------------------
 * 配列を宣言するときには、[]で要素数を指定し、
 * 配列の要素を使うときは、[]で番号を指定するのですが、
 * 実は、この2つもまったく別の記号です。
 * 
 * 宣言時の[]は要素数を指定するという意味を持ちますが、
 * 数式の中で使用する[]は、アドレスに足し算する演算子です。
 * 
 * C言語では、似た使い方には同じ記号を使いたがる傾向があり、
 * そのため、異なる意味に同じ記号を割り当てている部分が多いようです。
 * ----------------------------------------------
 */
